From bc201d4d8c30a89daee91c6443cb319eecb45738 Mon Sep 17 00:00:00 2001
From: Zach Brown <Zbob750@live.com>
Date: Tue, 22 Jul 2014 21:05:53 -0500
Subject: [PATCH] mc-dev imports


diff --git a/src/main/java/net/minecraft/server/BlockFalling.java b/src/main/java/net/minecraft/server/BlockFalling.java
new file mode 100644
index 0000000..473fc31
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFalling.java
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFalling extends Block {
+
+    public static boolean instaFall;
+
+    public BlockFalling() {
+        super(Material.SAND);
+        this.a(CreativeModeTab.b);
+    }
+
+    public BlockFalling(Material material) {
+        super(material);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        world.a(i, j, k, this, this.a(world));
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        world.a(i, j, k, this, this.a(world));
+    }
+
+    public void a(World world, int i, int j, int k, Random random) {
+        if (!world.isStatic) {
+            this.m(world, i, j, k);
+        }
+    }
+
+    private void m(World world, int i, int j, int k) {
+        if (canFall(world, i, j - 1, k) && j >= 0) {
+            byte b0 = 32;
+
+            if (!instaFall && world.b(i - b0, j - b0, k - b0, i + b0, j + b0, k + b0)) {
+                if (!world.isStatic) {
+                    EntityFallingBlock entityfallingblock = new EntityFallingBlock(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), this, world.getData(i, j, k));
+
+                    this.a(entityfallingblock);
+                    world.addEntity(entityfallingblock);
+                }
+            } else {
+                world.setAir(i, j, k);
+
+                while (canFall(world, i, j - 1, k) && j > 0) {
+                    --j;
+                }
+
+                if (j > 0) {
+                    world.setTypeUpdate(i, j, k, this);
+                }
+            }
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {}
+
+    public int a(World world) {
+        return 2;
+    }
+
+    public static boolean canFall(World world, int i, int j, int k) {
+        Block block = world.getType(i, j, k);
+
+        if (block.material == Material.AIR) {
+            return true;
+        } else if (block == Blocks.FIRE) {
+            return true;
+        } else {
+            Material material = block.material;
+
+            return material == Material.WATER ? true : material == Material.LAVA;
+        }
+    }
+
+    public void a(World world, int i, int j, int k, int l) {}
+}
diff --git a/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
new file mode 100644
index 0000000..d36aacb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
@@ -0,0 +1,145 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public abstract class BlockMinecartTrackAbstract extends Block {
+
+    protected final boolean a;
+
+    public static final boolean b_(World world, int i, int j, int k) {
+        return a(world.getType(i, j, k));
+    }
+
+    public static final boolean a(Block block) {
+        return block == Blocks.RAILS || block == Blocks.GOLDEN_RAIL || block == Blocks.DETECTOR_RAIL || block == Blocks.ACTIVATOR_RAIL;
+    }
+
+    protected BlockMinecartTrackAbstract(boolean flag) {
+        super(Material.ORIENTABLE);
+        this.a = flag;
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        this.a(CreativeModeTab.e);
+    }
+
+    public boolean e() {
+        return this.a;
+    }
+
+    public AxisAlignedBB a(World world, int i, int j, int k) {
+        return null;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public MovingObjectPosition a(World world, int i, int j, int k, Vec3D vec3d, Vec3D vec3d1) {
+        this.updateShape(world, i, j, k);
+        return super.a(world, i, j, k, vec3d, vec3d1);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, int i, int j, int k) {
+        int l = iblockaccess.getData(i, j, k);
+
+        if (l >= 2 && l <= 5) {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.625F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        }
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public int b() {
+        return 9;
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return World.a((IBlockAccess) world, i, j - 1, k);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        if (!world.isStatic) {
+            this.a(world, i, j, k, true);
+            if (this.a) {
+                this.doPhysics(world, i, j, k, this);
+            }
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (!world.isStatic) {
+            int l = world.getData(i, j, k);
+            int i1 = l;
+
+            if (this.a) {
+                i1 = l & 7;
+            }
+
+            boolean flag = false;
+
+            if (!World.a((IBlockAccess) world, i, j - 1, k)) {
+                flag = true;
+            }
+
+            if (i1 == 2 && !World.a((IBlockAccess) world, i + 1, j, k)) {
+                flag = true;
+            }
+
+            if (i1 == 3 && !World.a((IBlockAccess) world, i - 1, j, k)) {
+                flag = true;
+            }
+
+            if (i1 == 4 && !World.a((IBlockAccess) world, i, j, k - 1)) {
+                flag = true;
+            }
+
+            if (i1 == 5 && !World.a((IBlockAccess) world, i, j, k + 1)) {
+                flag = true;
+            }
+
+            if (flag) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+            } else {
+                this.a(world, i, j, k, l, i1, block);
+            }
+        }
+    }
+
+    protected void a(World world, int i, int j, int k, int l, int i1, Block block) {}
+
+    protected void a(World world, int i, int j, int k, boolean flag) {
+        if (!world.isStatic) {
+            (new MinecartTrackLogic(this, world, i, j, k)).a(world.isBlockIndirectlyPowered(i, j, k), flag);
+        }
+    }
+
+    public int h() {
+        return 0;
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        int i1 = l;
+
+        if (this.a) {
+            i1 = l & 7;
+        }
+
+        super.remove(world, i, j, k, block, l);
+        if (i1 == 2 || i1 == 3 || i1 == 4 || i1 == 5) {
+            world.applyPhysics(i, j + 1, k, block);
+        }
+
+        if (this.a) {
+            world.applyPhysics(i, j, k, block);
+            world.applyPhysics(i, j - 1, k, block);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTorch.java b/src/main/java/net/minecraft/server/BlockTorch.java
new file mode 100644
index 0000000..d95aff2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTorch.java
@@ -0,0 +1,167 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTorch extends Block {
+
+    protected BlockTorch() {
+        super(Material.ORIENTABLE);
+        this.a(true);
+        this.a(CreativeModeTab.c);
+    }
+
+    public AxisAlignedBB a(World world, int i, int j, int k) {
+        return null;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public int b() {
+        return 2;
+    }
+
+    private boolean m(World world, int i, int j, int k) {
+        if (World.a((IBlockAccess) world, i, j, k)) {
+            return true;
+        } else {
+            Block block = world.getType(i, j, k);
+
+            return block == Blocks.FENCE || block == Blocks.NETHER_FENCE || block == Blocks.GLASS || block == Blocks.COBBLE_WALL;
+        }
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return world.c(i - 1, j, k, true) ? true : (world.c(i + 1, j, k, true) ? true : (world.c(i, j, k - 1, true) ? true : (world.c(i, j, k + 1, true) ? true : this.m(world, i, j - 1, k))));
+    }
+
+    public int getPlacedData(World world, int i, int j, int k, int l, float f, float f1, float f2, int i1) {
+        int j1 = i1;
+
+        if (l == 1 && this.m(world, i, j - 1, k)) {
+            j1 = 5;
+        }
+
+        if (l == 2 && world.c(i, j, k + 1, true)) {
+            j1 = 4;
+        }
+
+        if (l == 3 && world.c(i, j, k - 1, true)) {
+            j1 = 3;
+        }
+
+        if (l == 4 && world.c(i + 1, j, k, true)) {
+            j1 = 2;
+        }
+
+        if (l == 5 && world.c(i - 1, j, k, true)) {
+            j1 = 1;
+        }
+
+        return j1;
+    }
+
+    public void a(World world, int i, int j, int k, Random random) {
+        super.a(world, i, j, k, random);
+        if (world.getData(i, j, k) == 0) {
+            this.onPlace(world, i, j, k);
+        }
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        if (world.getData(i, j, k) == 0) {
+            if (world.c(i - 1, j, k, true)) {
+                world.setData(i, j, k, 1, 2);
+            } else if (world.c(i + 1, j, k, true)) {
+                world.setData(i, j, k, 2, 2);
+            } else if (world.c(i, j, k - 1, true)) {
+                world.setData(i, j, k, 3, 2);
+            } else if (world.c(i, j, k + 1, true)) {
+                world.setData(i, j, k, 4, 2);
+            } else if (this.m(world, i, j - 1, k)) {
+                world.setData(i, j, k, 5, 2);
+            }
+        }
+
+        this.e(world, i, j, k);
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        this.b(world, i, j, k, block);
+    }
+
+    protected boolean b(World world, int i, int j, int k, Block block) {
+        if (this.e(world, i, j, k)) {
+            int l = world.getData(i, j, k);
+            boolean flag = false;
+
+            if (!world.c(i - 1, j, k, true) && l == 1) {
+                flag = true;
+            }
+
+            if (!world.c(i + 1, j, k, true) && l == 2) {
+                flag = true;
+            }
+
+            if (!world.c(i, j, k - 1, true) && l == 3) {
+                flag = true;
+            }
+
+            if (!world.c(i, j, k + 1, true) && l == 4) {
+                flag = true;
+            }
+
+            if (!this.m(world, i, j - 1, k) && l == 5) {
+                flag = true;
+            }
+
+            if (flag) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            return true;
+        }
+    }
+
+    protected boolean e(World world, int i, int j, int k) {
+        if (!this.canPlace(world, i, j, k)) {
+            if (world.getType(i, j, k) == this) {
+                this.b(world, i, j, k, world.getData(i, j, k), 0);
+                world.setAir(i, j, k);
+            }
+
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    public MovingObjectPosition a(World world, int i, int j, int k, Vec3D vec3d, Vec3D vec3d1) {
+        int l = world.getData(i, j, k) & 7;
+        float f = 0.15F;
+
+        if (l == 1) {
+            this.a(0.0F, 0.2F, 0.5F - f, f * 2.0F, 0.8F, 0.5F + f);
+        } else if (l == 2) {
+            this.a(1.0F - f * 2.0F, 0.2F, 0.5F - f, 1.0F, 0.8F, 0.5F + f);
+        } else if (l == 3) {
+            this.a(0.5F - f, 0.2F, 0.0F, 0.5F + f, 0.8F, f * 2.0F);
+        } else if (l == 4) {
+            this.a(0.5F - f, 0.2F, 1.0F - f * 2.0F, 0.5F + f, 0.8F, 1.0F);
+        } else {
+            f = 0.1F;
+            this.a(0.5F - f, 0.0F, 0.5F - f, 0.5F + f, 0.6F, 0.5F + f);
+        }
+
+        return super.a(world, i, j, k, vec3d, vec3d1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderFlat.java b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
new file mode 100644
index 0000000..0f75182
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
@@ -0,0 +1,238 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class ChunkProviderFlat implements IChunkProvider {
+
+    private World a;
+    private Random b;
+    private final Block[] c = new Block[256];
+    private final byte[] d = new byte[256];
+    private final WorldGenFlatInfo e;
+    private final List f = new ArrayList();
+    private final boolean g;
+    private final boolean h;
+    private WorldGenLakes i;
+    private WorldGenLakes j;
+
+    public ChunkProviderFlat(World world, long i, boolean flag, String s) {
+        this.a = world;
+        this.b = new Random(i);
+        this.e = WorldGenFlatInfo.a(s);
+        if (flag) {
+            Map map = this.e.b();
+
+            if (map.containsKey("village")) {
+                Map map1 = (Map) map.get("village");
+
+                if (!map1.containsKey("size")) {
+                    map1.put("size", "1");
+                }
+
+                this.f.add(new WorldGenVillage(map1));
+            }
+
+            if (map.containsKey("biome_1")) {
+                this.f.add(new WorldGenLargeFeature((Map) map.get("biome_1")));
+            }
+
+            if (map.containsKey("mineshaft")) {
+                this.f.add(new WorldGenMineshaft((Map) map.get("mineshaft")));
+            }
+
+            if (map.containsKey("stronghold")) {
+                this.f.add(new WorldGenStronghold((Map) map.get("stronghold")));
+            }
+        }
+
+        this.g = this.e.b().containsKey("decoration");
+        if (this.e.b().containsKey("lake")) {
+            this.i = new WorldGenLakes(Blocks.STATIONARY_WATER);
+        }
+
+        if (this.e.b().containsKey("lava_lake")) {
+            this.j = new WorldGenLakes(Blocks.STATIONARY_LAVA);
+        }
+
+        this.h = this.e.b().containsKey("dungeon");
+        Iterator iterator = this.e.c().iterator();
+
+        while (iterator.hasNext()) {
+            WorldGenFlatLayerInfo worldgenflatlayerinfo = (WorldGenFlatLayerInfo) iterator.next();
+
+            for (int j = worldgenflatlayerinfo.d(); j < worldgenflatlayerinfo.d() + worldgenflatlayerinfo.a(); ++j) {
+                this.c[j] = worldgenflatlayerinfo.b();
+                this.d[j] = (byte) worldgenflatlayerinfo.c();
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        Chunk chunk = new Chunk(this.a, i, j);
+
+        int k;
+
+        for (int l = 0; l < this.c.length; ++l) {
+            Block block = this.c[l];
+
+            if (block != null) {
+                k = l >> 4;
+                ChunkSection chunksection = chunk.getSections()[k];
+
+                if (chunksection == null) {
+                    chunksection = new ChunkSection(l, !this.a.worldProvider.g);
+                    chunk.getSections()[k] = chunksection;
+                }
+
+                for (int i1 = 0; i1 < 16; ++i1) {
+                    for (int j1 = 0; j1 < 16; ++j1) {
+                        chunksection.setTypeId(i1, l & 15, j1, block);
+                        chunksection.setData(i1, l & 15, j1, this.d[l]);
+                    }
+                }
+            }
+        }
+
+        chunk.initLighting();
+        BiomeBase[] abiomebase = this.a.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.m();
+
+        for (k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) abiomebase[k].id;
+        }
+
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            WorldGenBase worldgenbase = (WorldGenBase) iterator.next();
+
+            worldgenbase.a(this, this.a, i, j, (Block[]) null);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        int k = i * 16;
+        int l = j * 16;
+        BiomeBase biomebase = this.a.getBiome(k + 16, l + 16);
+        boolean flag = false;
+
+        this.b.setSeed(this.a.getSeed());
+        long i1 = this.b.nextLong() / 2L * 2L + 1L;
+        long j1 = this.b.nextLong() / 2L * 2L + 1L;
+
+        this.b.setSeed((long) i * i1 + (long) j * j1 ^ this.a.getSeed());
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+            boolean flag1 = structuregenerator.a(this.a, this.b, i, j);
+
+            if (structuregenerator instanceof WorldGenVillage) {
+                flag |= flag1;
+            }
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (this.i != null && !flag && this.b.nextInt(4) == 0) {
+            l1 = k + this.b.nextInt(16) + 8;
+            k1 = this.b.nextInt(256);
+            i2 = l + this.b.nextInt(16) + 8;
+            this.i.generate(this.a, this.b, l1, k1, i2);
+        }
+
+        if (this.j != null && !flag && this.b.nextInt(8) == 0) {
+            l1 = k + this.b.nextInt(16) + 8;
+            k1 = this.b.nextInt(this.b.nextInt(248) + 8);
+            i2 = l + this.b.nextInt(16) + 8;
+            if (k1 < 63 || this.b.nextInt(10) == 0) {
+                this.j.generate(this.a, this.b, l1, k1, i2);
+            }
+        }
+
+        if (this.h) {
+            for (l1 = 0; l1 < 8; ++l1) {
+                k1 = k + this.b.nextInt(16) + 8;
+                i2 = this.b.nextInt(256);
+                int j2 = l + this.b.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.a, this.b, k1, i2, j2);
+            }
+        }
+
+        if (this.g) {
+            biomebase.a(this.a, this.b, k, l);
+        }
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "FlatLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        BiomeBase biomebase = this.a.getBiome(i, k);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        if ("Stronghold".equals(s)) {
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+
+                if (structuregenerator instanceof WorldGenStronghold) {
+                    return structuregenerator.getNearestGeneratedFeature(world, i, j, k);
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        Iterator iterator = this.f.iterator();
+
+        while (iterator.hasNext()) {
+            StructureGenerator structuregenerator = (StructureGenerator) iterator.next();
+
+            structuregenerator.a(this, this.a, i, j, (Block[]) null);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
new file mode 100644
index 0000000..813df4d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
@@ -0,0 +1,392 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGeneratorOctaves l;
+    private NoiseGenerator3 m;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World n;
+    private final boolean o;
+    private WorldType p;
+    private final double[] q;
+    private final float[] r;
+    private double[] s = new double[256];
+    private WorldGenBase t = new WorldGenCaves();
+    private WorldGenStronghold u = new WorldGenStronghold();
+    private WorldGenVillage v = new WorldGenVillage();
+    private WorldGenMineshaft w = new WorldGenMineshaft();
+    private WorldGenLargeFeature x = new WorldGenLargeFeature();
+    private WorldGenBase y = new WorldGenCanyon();
+    private BiomeBase[] z;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+    int[][] h = new int[32][32];
+
+    public ChunkProviderGenerate(World world, long i, boolean flag) {
+        this.n = world;
+        this.o = flag;
+        this.p = world.getWorldData().getType();
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGenerator3(this.i, 4);
+        this.a = new NoiseGeneratorOctaves(this.i, 10);
+        this.b = new NoiseGeneratorOctaves(this.i, 16);
+        this.c = new NoiseGeneratorOctaves(this.i, 8);
+        this.q = new double[825];
+        this.r = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.r[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+    }
+
+    public void a(int i, int j, Block[] ablock) {
+        byte b0 = 63;
+
+        this.z = this.n.getWorldChunkManager().getBiomes(this.z, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.q[k1 + k2];
+                    double d2 = this.q[l1 + k2];
+                    double d3 = this.q[i2 + k2];
+                    double d4 = this.q[j2 + k2];
+                    double d5 = (this.q[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.q[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.q[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.q[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            int j3 = i3 + k * 4 << 12 | 0 + j1 * 4 << 8 | k2 * 8 + l2;
+                            short short1 = 256;
+
+                            j3 -= short1;
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int k3 = 0; k3 < 4; ++k3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    ablock[j3 += short1] = Blocks.STONE;
+                                } else if (k2 * 8 + l2 < b0) {
+                                    ablock[j3 += short1] = Blocks.STATIONARY_WATER;
+                                } else {
+                                    ablock[j3 += short1] = null;
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+    }
+
+    public void a(int i, int j, Block[] ablock, byte[] abyte, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.s = this.m.a(this.s, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.n, this.i, ablock, abyte, i * 16 + k, j * 16 + l, this.s[l + k * 16]);
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        Block[] ablock = new Block[65536];
+        byte[] abyte = new byte[65536];
+
+        this.a(i, j, ablock);
+        this.z = this.n.getWorldChunkManager().getBiomeBlock(this.z, i * 16, j * 16, 16, 16);
+        this.a(i, j, ablock, abyte, this.z);
+        this.t.a(this, this.n, i, j, ablock);
+        this.y.a(this, this.n, i, j, ablock);
+        if (this.o) {
+            this.w.a(this, this.n, i, j, ablock);
+            this.v.a(this, this.n, i, j, ablock);
+            this.u.a(this, this.n, i, j, ablock);
+            this.x.a(this, this.n, i, j, ablock);
+        }
+
+        Chunk chunk = new Chunk(this.n, ablock, abyte, i, j);
+        byte[] abyte1 = chunk.m();
+
+        for (int k = 0; k < abyte1.length; ++k) {
+            abyte1[k] = (byte) this.z[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        double d0 = 684.412D;
+        double d1 = 684.412D;
+        double d2 = 512.0D;
+        double d3 = 512.0D;
+
+        this.g = this.b.a(this.g, i, k, 5, 5, 200.0D, 200.0D, 0.5D);
+        this.d = this.l.a(this.d, i, j, k, 5, 33, 5, 8.555150000000001D, 4.277575000000001D, 8.555150000000001D);
+        this.e = this.j.a(this.e, i, j, k, 5, 33, 5, 684.412D, 684.412D, 684.412D);
+        this.f = this.k.a(this.f, i, j, k, 5, 33, 5, 684.412D, 684.412D, 684.412D);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+        double d4 = 8.5D;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f = 0.0F;
+                float f1 = 0.0F;
+                float f2 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.z[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.z[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f3 = biomebase1.am;
+                        float f4 = biomebase1.an;
+
+                        if (this.p == WorldType.AMPLIFIED && f3 > 0.0F) {
+                            f3 = 1.0F + f3 * 2.0F;
+                            f4 = 1.0F + f4 * 4.0F;
+                        }
+
+                        float f5 = this.r[l1 + 2 + (i2 + 2) * 5] / (f3 + 2.0F);
+
+                        if (biomebase1.am > biomebase.am) {
+                            f5 /= 2.0F;
+                        }
+
+                        f += f4 * f5;
+                        f1 += f3 * f5;
+                        f2 += f5;
+                    }
+                }
+
+                f /= f2;
+                f1 /= f2;
+                f = f * 0.9F + 0.1F;
+                f1 = (f1 * 4.0F - 1.0F) / 8.0F;
+                double d5 = this.g[i1] / 8000.0D;
+
+                if (d5 < 0.0D) {
+                    d5 = -d5 * 0.3D;
+                }
+
+                d5 = d5 * 3.0D - 2.0D;
+                if (d5 < 0.0D) {
+                    d5 /= 2.0D;
+                    if (d5 < -1.0D) {
+                        d5 = -1.0D;
+                    }
+
+                    d5 /= 1.4D;
+                    d5 /= 2.0D;
+                } else {
+                    if (d5 > 1.0D) {
+                        d5 = 1.0D;
+                    }
+
+                    d5 /= 8.0D;
+                }
+
+                ++i1;
+                double d6 = (double) f1;
+                double d7 = (double) f;
+
+                d6 += d5 * 0.2D;
+                d6 = d6 * 8.5D / 8.0D;
+                double d8 = 8.5D + d6 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d9 = ((double) j2 - d8) * 12.0D * 128.0D / 256.0D / d7;
+
+                    if (d9 < 0.0D) {
+                        d9 *= 4.0D;
+                    }
+
+                    double d10 = this.e[l] / 512.0D;
+                    double d11 = this.f[l] / 512.0D;
+                    double d12 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d13 = MathHelper.b(d10, d11, d12) - d9;
+
+                    if (j2 > 29) {
+                        double d14 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d13 = d13 * (1.0D - d14) + -10.0D * d14;
+                    }
+
+                    this.q[l] = d13;
+                    ++l;
+                }
+            }
+        }
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BiomeBase biomebase = this.n.getBiome(k + 16, l + 16);
+
+        this.i.setSeed(this.n.getSeed());
+        long i1 = this.i.nextLong() / 2L * 2L + 1L;
+        long j1 = this.i.nextLong() / 2L * 2L + 1L;
+
+        this.i.setSeed((long) i * i1 + (long) j * j1 ^ this.n.getSeed());
+        boolean flag = false;
+
+        if (this.o) {
+            this.w.a(this.n, this.i, i, j);
+            flag = this.v.a(this.n, this.i, i, j);
+            this.u.a(this.n, this.i, i, j);
+            this.x.a(this.n, this.i, i, j);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && !flag && this.i.nextInt(4) == 0) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(256);
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.STATIONARY_WATER)).generate(this.n, this.i, k1, l1, i2);
+        }
+
+        if (!flag && this.i.nextInt(8) == 0) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(this.i.nextInt(248) + 8);
+            i2 = l + this.i.nextInt(16) + 8;
+            if (l1 < 63 || this.i.nextInt(10) == 0) {
+                (new WorldGenLakes(Blocks.STATIONARY_LAVA)).generate(this.n, this.i, k1, l1, i2);
+            }
+        }
+
+        for (k1 = 0; k1 < 8; ++k1) {
+            l1 = k + this.i.nextInt(16) + 8;
+            i2 = this.i.nextInt(256);
+            int j2 = l + this.i.nextInt(16) + 8;
+
+            (new WorldGenDungeons()).generate(this.n, this.i, l1, i2, j2);
+        }
+
+        biomebase.a(this.n, this.i, k, l);
+        SpawnerCreature.a(this.n, biomebase, k + 8, l + 8, 16, 16, this.i);
+        k += 8;
+        l += 8;
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                i2 = this.n.h(k + k1, l + l1);
+                if (this.n.r(k1 + k, i2 - 1, l1 + l)) {
+                    this.n.setTypeAndData(k1 + k, i2 - 1, l1 + l, Blocks.ICE, 0, 2);
+                }
+
+                if (this.n.e(k1 + k, i2, l1 + l, true)) {
+                    this.n.setTypeAndData(k1 + k, i2, l1 + l, Blocks.SNOW, 0, 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        BiomeBase biomebase = this.n.getBiome(i, k);
+
+        return enumcreaturetype == EnumCreatureType.MONSTER && this.x.a(i, j, k) ? this.x.b() : biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        return "Stronghold".equals(s) && this.u != null ? this.u.getNearestGeneratedFeature(world, i, j, k) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        if (this.o) {
+            this.w.a(this, this.n, i, j, (Block[]) null);
+            this.v.a(this, this.n, i, j, (Block[]) null);
+            this.u.a(this, this.n, i, j, (Block[]) null);
+            this.x.a(this, this.n, i, j, (Block[]) null);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderHell.java b/src/main/java/net/minecraft/server/ChunkProviderHell.java
new file mode 100644
index 0000000..ef4894e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkProviderHell.java
@@ -0,0 +1,445 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class ChunkProviderHell implements IChunkProvider {
+
+    private Random i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGeneratorOctaves l;
+    private NoiseGeneratorOctaves m;
+    private NoiseGeneratorOctaves n;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    private World o;
+    private double[] p;
+    public WorldGenNether c = new WorldGenNether();
+    private double[] q = new double[256];
+    private double[] r = new double[256];
+    private double[] s = new double[256];
+    private WorldGenBase t = new WorldGenCavesHell();
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+    double[] h;
+
+    public ChunkProviderHell(World world, long i) {
+        this.o = world;
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGeneratorOctaves(this.i, 4);
+        this.n = new NoiseGeneratorOctaves(this.i, 4);
+        this.a = new NoiseGeneratorOctaves(this.i, 10);
+        this.b = new NoiseGeneratorOctaves(this.i, 16);
+    }
+
+    public void a(int i, int j, Block[] ablock) {
+        byte b0 = 4;
+        byte b1 = 32;
+        int k = b0 + 1;
+        byte b2 = 17;
+        int l = b0 + 1;
+
+        this.p = this.a(this.p, i * b0, 0, j * b0, k, b2, l);
+
+        for (int i1 = 0; i1 < b0; ++i1) {
+            for (int j1 = 0; j1 < b0; ++j1) {
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[((i1 + 0) * l + j1 + 0) * b2 + k1 + 0];
+                    double d2 = this.p[((i1 + 0) * l + j1 + 1) * b2 + k1 + 0];
+                    double d3 = this.p[((i1 + 1) * l + j1 + 0) * b2 + k1 + 0];
+                    double d4 = this.p[((i1 + 1) * l + j1 + 1) * b2 + k1 + 0];
+                    double d5 = (this.p[((i1 + 0) * l + j1 + 0) * b2 + k1 + 1] - d1) * d0;
+                    double d6 = (this.p[((i1 + 0) * l + j1 + 1) * b2 + k1 + 1] - d2) * d0;
+                    double d7 = (this.p[((i1 + 1) * l + j1 + 0) * b2 + k1 + 1] - d3) * d0;
+                    double d8 = (this.p[((i1 + 1) * l + j1 + 1) * b2 + k1 + 1] - d4) * d0;
+
+                    for (int l1 = 0; l1 < 8; ++l1) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i2 = 0; i2 < 4; ++i2) {
+                            int j2 = i2 + i1 * 4 << 11 | 0 + j1 * 4 << 7 | k1 * 8 + l1;
+                            short short1 = 128;
+                            double d14 = 0.25D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int k2 = 0; k2 < 4; ++k2) {
+                                Block block = null;
+
+                                if (k1 * 8 + l1 < b1) {
+                                    block = Blocks.STATIONARY_LAVA;
+                                }
+
+                                if (d15 > 0.0D) {
+                                    block = Blocks.NETHERRACK;
+                                }
+
+                                ablock[j2] = block;
+                                j2 += short1;
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+    }
+
+    public void b(int i, int j, Block[] ablock) {
+        byte b0 = 64;
+        double d0 = 0.03125D;
+
+        this.q = this.m.a(this.q, i * 16, j * 16, 0, 16, 16, 1, d0, d0, 1.0D);
+        this.r = this.m.a(this.r, i * 16, 109, j * 16, 16, 1, 16, d0, 1.0D, d0);
+        this.s = this.n.a(this.s, i * 16, j * 16, 0, 16, 16, 1, d0 * 2.0D, d0 * 2.0D, d0 * 2.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                boolean flag = this.q[k + l * 16] + this.i.nextDouble() * 0.2D > 0.0D;
+                boolean flag1 = this.r[k + l * 16] + this.i.nextDouble() * 0.2D > 0.0D;
+                int i1 = (int) (this.s[k + l * 16] / 3.0D + 3.0D + this.i.nextDouble() * 0.25D);
+                int j1 = -1;
+                Block block = Blocks.NETHERRACK;
+                Block block1 = Blocks.NETHERRACK;
+
+                for (int k1 = 127; k1 >= 0; --k1) {
+                    int l1 = (l * 16 + k) * 128 + k1;
+
+                    if (k1 < 127 - this.i.nextInt(5) && k1 > 0 + this.i.nextInt(5)) {
+                        Block block2 = ablock[l1];
+
+                        if (block2 != null && block2.getMaterial() != Material.AIR) {
+                            if (block2 == Blocks.NETHERRACK) {
+                                if (j1 == -1) {
+                                    if (i1 <= 0) {
+                                        block = null;
+                                        block1 = Blocks.NETHERRACK;
+                                    } else if (k1 >= b0 - 4 && k1 <= b0 + 1) {
+                                        block = Blocks.NETHERRACK;
+                                        block1 = Blocks.NETHERRACK;
+                                        if (flag1) {
+                                            block = Blocks.GRAVEL;
+                                            block1 = Blocks.NETHERRACK;
+                                        }
+
+                                        if (flag) {
+                                            block = Blocks.SOUL_SAND;
+                                            block1 = Blocks.SOUL_SAND;
+                                        }
+                                    }
+
+                                    if (k1 < b0 && (block == null || block.getMaterial() == Material.AIR)) {
+                                        block = Blocks.STATIONARY_LAVA;
+                                    }
+
+                                    j1 = i1;
+                                    if (k1 >= b0 - 1) {
+                                        ablock[l1] = block;
+                                    } else {
+                                        ablock[l1] = block1;
+                                    }
+                                } else if (j1 > 0) {
+                                    --j1;
+                                    ablock[l1] = block1;
+                                }
+                            }
+                        } else {
+                            j1 = -1;
+                        }
+                    } else {
+                        ablock[l1] = Blocks.BEDROCK;
+                    }
+                }
+            }
+        }
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.getOrCreateChunk(i, j);
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        Block[] ablock = new Block['\u8000'];
+
+        this.a(i, j, ablock);
+        this.b(i, j, ablock);
+        this.t.a(this, this.o, i, j, ablock);
+        this.c.a(this, this.o, i, j, ablock);
+        Chunk chunk = new Chunk(this.o, ablock, i, j);
+        BiomeBase[] abiomebase = this.o.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.m();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) abiomebase[k].id;
+        }
+
+        chunk.n();
+        return chunk;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 2053.236D;
+
+        this.g = this.a.a(this.g, i, j, k, l, 1, j1, 1.0D, 0.0D, 1.0D);
+        this.h = this.b.a(this.h, i, j, k, l, 1, j1, 100.0D, 0.0D, 100.0D);
+        this.d = this.l.a(this.d, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 60.0D, d0 / 80.0D);
+        this.e = this.j.a(this.e, i, j, k, l, i1, j1, d0, d1, d0);
+        this.f = this.k.a(this.f, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = 0;
+        int l1 = 0;
+        double[] adouble1 = new double[i1];
+
+        int i2;
+
+        for (i2 = 0; i2 < i1; ++i2) {
+            adouble1[i2] = Math.cos((double) i2 * 3.141592653589793D * 6.0D / (double) i1) * 2.0D;
+            double d2 = (double) i2;
+
+            if (i2 > i1 / 2) {
+                d2 = (double) (i1 - 1 - i2);
+            }
+
+            if (d2 < 4.0D) {
+                d2 = 4.0D - d2;
+                adouble1[i2] -= d2 * d2 * d2 * 10.0D;
+            }
+        }
+
+        for (i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < j1; ++j2) {
+                double d3 = (this.g[l1] + 256.0D) / 512.0D;
+
+                if (d3 > 1.0D) {
+                    d3 = 1.0D;
+                }
+
+                double d4 = 0.0D;
+                double d5 = this.h[l1] / 8000.0D;
+
+                if (d5 < 0.0D) {
+                    d5 = -d5;
+                }
+
+                d5 = d5 * 3.0D - 3.0D;
+                if (d5 < 0.0D) {
+                    d5 /= 2.0D;
+                    if (d5 < -1.0D) {
+                        d5 = -1.0D;
+                    }
+
+                    d5 /= 1.4D;
+                    d5 /= 2.0D;
+                    d3 = 0.0D;
+                } else {
+                    if (d5 > 1.0D) {
+                        d5 = 1.0D;
+                    }
+
+                    d5 /= 6.0D;
+                }
+
+                d3 += 0.5D;
+                d5 = d5 * (double) i1 / 16.0D;
+                ++l1;
+
+                for (int k2 = 0; k2 < i1; ++k2) {
+                    double d6 = 0.0D;
+                    double d7 = adouble1[k2];
+                    double d8 = this.e[k1] / 512.0D;
+                    double d9 = this.f[k1] / 512.0D;
+                    double d10 = (this.d[k1] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d10 < 0.0D) {
+                        d6 = d8;
+                    } else if (d10 > 1.0D) {
+                        d6 = d9;
+                    } else {
+                        d6 = d8 + (d9 - d8) * d10;
+                    }
+
+                    d6 -= d7;
+                    double d11;
+
+                    if (k2 > i1 - 4) {
+                        d11 = (double) ((float) (k2 - (i1 - 4)) / 3.0F);
+                        d6 = d6 * (1.0D - d11) + -10.0D * d11;
+                    }
+
+                    if ((double) k2 < d4) {
+                        d11 = (d4 - (double) k2) / 4.0D;
+                        if (d11 < 0.0D) {
+                            d11 = 0.0D;
+                        }
+
+                        if (d11 > 1.0D) {
+                            d11 = 1.0D;
+                        }
+
+                        d6 = d6 * (1.0D - d11) + -10.0D * d11;
+                    }
+
+                    adouble[k1] = d6;
+                    ++k1;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+
+        this.c.a(this.o, this.i, i, j);
+
+        int i1;
+        int j1;
+        int k1;
+        int l1;
+
+        for (i1 = 0; i1 < 8; ++i1) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(120) + 4;
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenHellLava(Blocks.LAVA, false)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        i1 = this.i.nextInt(this.i.nextInt(10) + 1) + 1;
+
+        int i2;
+
+        for (j1 = 0; j1 < i1; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(120) + 4;
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFire()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        i1 = this.i.nextInt(this.i.nextInt(10) + 1);
+
+        for (j1 = 0; j1 < i1; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(120) + 4;
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLightStone1()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        for (j1 = 0; j1 < 10; ++j1) {
+            k1 = k + this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(128);
+            i2 = l + this.i.nextInt(16) + 8;
+            (new WorldGenLightStone2()).generate(this.o, this.i, k1, l1, i2);
+        }
+
+        if (this.i.nextInt(1) == 0) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(128);
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFlowers(Blocks.BROWN_MUSHROOM)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        if (this.i.nextInt(1) == 0) {
+            j1 = k + this.i.nextInt(16) + 8;
+            k1 = this.i.nextInt(128);
+            l1 = l + this.i.nextInt(16) + 8;
+            (new WorldGenFlowers(Blocks.RED_MUSHROOM)).generate(this.o, this.i, j1, k1, l1);
+        }
+
+        WorldGenMinable worldgenminable = new WorldGenMinable(Blocks.QUARTZ_ORE, 13, Blocks.NETHERRACK);
+
+        int j2;
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            l1 = k + this.i.nextInt(16);
+            i2 = this.i.nextInt(108) + 10;
+            j2 = l + this.i.nextInt(16);
+            worldgenminable.generate(this.o, this.i, l1, i2, j2);
+        }
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            l1 = k + this.i.nextInt(16);
+            i2 = this.i.nextInt(108) + 10;
+            j2 = l + this.i.nextInt(16);
+            (new WorldGenHellLava(Blocks.LAVA, true)).generate(this.o, this.i, l1, i2, j2);
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "HellRandomLevelSource";
+    }
+
+    public List getMobsFor(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+        if (enumcreaturetype == EnumCreatureType.MONSTER) {
+            if (this.c.b(i, j, k)) {
+                return this.c.b();
+            }
+
+            if (this.c.d(i, j, k) && this.o.getType(i, j - 1, k) == Blocks.NETHER_BRICK) {
+                return this.c.b();
+            }
+        }
+
+        BiomeBase biomebase = this.o.getBiome(i, k);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public ChunkPosition findNearestMapFeature(World world, String s, int i, int j, int k) {
+        return null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(int i, int j) {
+        this.c.a(this, this.o, i, j, (Block[]) null);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MobEffectAttackDamage.java b/src/main/java/net/minecraft/server/MobEffectAttackDamage.java
new file mode 100644
index 0000000..3eb029d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MobEffectAttackDamage.java
@@ -0,0 +1,12 @@
+package net.minecraft.server;
+
+public class MobEffectAttackDamage extends MobEffectList {
+
+    protected MobEffectAttackDamage(int i, boolean flag, int j) {
+        super(i, flag, j);
+    }
+
+    public double a(int i, AttributeModifier attributemodifier) {
+        return this.id == MobEffectList.WEAKNESS.id ? (double) (-0.5F * (float) (i + 1)) : 1.3D * (double) (i + 1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RandomPositionGenerator.java b/src/main/java/net/minecraft/server/RandomPositionGenerator.java
new file mode 100644
index 0000000..9342a3f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RandomPositionGenerator.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class RandomPositionGenerator {
+
+    private static Vec3D a = Vec3D.a(0.0D, 0.0D, 0.0D);
+
+    public static Vec3D a(EntityCreature entitycreature, int i, int j) {
+        return c(entitycreature, i, j, (Vec3D) null);
+    }
+
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        a.a = vec3d.a - entitycreature.locX;
+        a.b = vec3d.b - entitycreature.locY;
+        a.c = vec3d.c - entitycreature.locZ;
+        return c(entitycreature, i, j, a);
+    }
+
+    public static Vec3D b(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        a.a = entitycreature.locX - vec3d.a;
+        a.b = entitycreature.locY - vec3d.b;
+        a.c = entitycreature.locZ - vec3d.c;
+        return c(entitycreature, i, j, a);
+    }
+
+    private static Vec3D c(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Random random = entitycreature.aI();
+        boolean flag = false;
+        int k = 0;
+        int l = 0;
+        int i1 = 0;
+        float f = -99999.0F;
+        boolean flag1;
+
+        if (entitycreature.bY()) {
+            double d0 = (double) (entitycreature.bV().e(MathHelper.floor(entitycreature.locX), MathHelper.floor(entitycreature.locY), MathHelper.floor(entitycreature.locZ)) + 4.0F);
+            double d1 = (double) (entitycreature.bW() + (float) i);
+
+            flag1 = d0 < d1 * d1;
+        } else {
+            flag1 = false;
+        }
+
+        for (int j1 = 0; j1 < 10; ++j1) {
+            int k1 = random.nextInt(2 * i) - i;
+            int l1 = random.nextInt(2 * j) - j;
+            int i2 = random.nextInt(2 * i) - i;
+
+            if (vec3d == null || (double) k1 * vec3d.a + (double) i2 * vec3d.c >= 0.0D) {
+                k1 += MathHelper.floor(entitycreature.locX);
+                l1 += MathHelper.floor(entitycreature.locY);
+                i2 += MathHelper.floor(entitycreature.locZ);
+                if (!flag1 || entitycreature.b(k1, l1, i2)) {
+                    float f1 = entitycreature.a(k1, l1, i2);
+
+                    if (f1 > f) {
+                        f = f1;
+                        k = k1;
+                        l = l1;
+                        i1 = i2;
+                        flag = true;
+                    }
+                }
+            }
+        }
+
+        if (flag) {
+            return Vec3D.a((double) k, (double) l, (double) i1);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 0000000..b205ab7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity {
+
+    public float a;
+    public float i;
+    public int j;
+    private int k;
+
+    public TileEntityEnderChest() {}
+
+    public void h() {
+        super.h();
+        if (++this.k % 20 * 4 == 0) {
+            this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+        }
+
+        this.i = this.a;
+        float f = 0.1F;
+        double d0;
+
+        if (this.j > 0 && this.a == 0.0F) {
+            double d1 = (double) this.x + 0.5D;
+
+            d0 = (double) this.z + 0.5D;
+            this.world.makeSound(d1, (double) this.y + 0.5D, d0, "random.chestopen", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.j == 0 && this.a > 0.0F || this.j > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.j > 0) {
+                this.a += f;
+            } else {
+                this.a -= f;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < f2 && f1 >= f2) {
+                d0 = (double) this.x + 0.5D;
+                double d2 = (double) this.z + 0.5D;
+
+                this.world.makeSound(d0, (double) this.y + 0.5D, d2, "random.chestclosed", 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.j = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void s() {
+        this.u();
+        super.s();
+    }
+
+    public void a() {
+        ++this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public void b() {
+        --this.j;
+        this.world.playBlockAction(this.x, this.y, this.z, Blocks.ENDER_CHEST, 1, this.j);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.x, this.y, this.z) != this ? false : entityhuman.e((double) this.x + 0.5D, (double) this.y + 0.5D, (double) this.z + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityLightDetector.java b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
new file mode 100644
index 0000000..143cffb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
@@ -0,0 +1,15 @@
+package net.minecraft.server;
+
+public class TileEntityLightDetector extends TileEntity {
+
+    public TileEntityLightDetector() {}
+
+    public void h() {
+        if (this.world != null && !this.world.isStatic && this.world.getTime() % 20L == 0L) {
+            this.h = this.q();
+            if (this.h instanceof BlockDaylightDetector) {
+                ((BlockDaylightDetector) this.h).e(this.world, this.x, this.y, this.z);
+            }
+        }
+    }
+}
-- 
1.9.4.msysgit.2

